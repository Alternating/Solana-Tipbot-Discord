const web3 = require('@solana/web3.js');
const splToken = require('@solana/spl-token');
const config = require('./solana.config.json');
const BigNumber = require('bignumber.js');

class SolanaService {
  constructor() {
    this.connection = null;
    this.init();
  }

  init() {
    const endpoint = config.network[config.settings.defaultNetwork];
    this.connection = new web3.Connection(endpoint, 'confirmed');
  }

  async getConnection() {
    if (!this.connection) {
      await this.init();
    }
    return this.connection;
  }

  async getBalance(publicKey) {
    try {
      const connection = await this.getConnection();
      const balance = await connection.getBalance(new web3.PublicKey(publicKey));
      return new BigNumber(balance).dividedBy(web3.LAMPORTS_PER_SOL);
    } catch (error) {
      console.error('Error getting balance:', error);
      throw error;
    }
  }

  async getTokenBalance(publicKey, mint) {
    try {
      const connection = await this.getConnection();
      const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
        new web3.PublicKey(publicKey),
        { mint: new web3.PublicKey(mint) }
      );
      
      if (tokenAccounts.value.length === 0) {
        return new BigNumber(0);
      }

      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount;
      return new BigNumber(balance.amount).dividedBy(10 ** balance.decimals);
    } catch (error) {
      console.error('Error getting token balance:', error);
      throw error;
    }
  }

  async validateAddress(address) {
    try {
      new web3.PublicKey(address);
      return true;
    } catch (error) {
      return false;
    }
  }

  async createTransaction(fromPubkey, toPubkey, amount, mint) {
    try {
      const connection = await this.getConnection();
      
      if (!mint) {
        // SOL transfer
        const transaction = new web3.Transaction().add(
          web3.SystemProgram.transfer({
            fromPubkey: new web3.PublicKey(fromPubkey),
            toPubkey: new web3.PublicKey(toPubkey),
            lamports: amount * web3.LAMPORTS_PER_SOL
          })
        );
        return transaction;
      } else {
        // SPL Token transfer
        const fromTokenAccount = await splToken.getAssociatedTokenAddress(
          new web3.PublicKey(mint),
          new web3.PublicKey(fromPubkey)
        );

        const toTokenAccount = await splToken.getAssociatedTokenAddress(
          new web3.PublicKey(mint),
          new web3.PublicKey(toPubkey)
        );

        const transaction = new web3.Transaction();

        // Check if destination token account exists
        const toAccountInfo = await connection.getAccountInfo(toTokenAccount);
        if (!toAccountInfo) {
          transaction.add(
            splToken.createAssociatedTokenAccountInstruction(
              new web3.PublicKey(fromPubkey),
              toTokenAccount,
              new web3.PublicKey(toPubkey),
              new web3.PublicKey(mint)
            )
          );
        }

        transaction.add(
          splToken.createTransferInstruction(
            fromTokenAccount,
            toTokenAccount,
            new web3.PublicKey(fromPubkey),
            amount * (10 ** config.settings.maxDecimals)
          )
        );

        return transaction;
      }
    } catch (error) {
      console.error('Error creating transaction:', error);
      throw error;
    }
  }
}

module.exports = new SolanaService();
